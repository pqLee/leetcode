## 堆
1.首先我们需要找到最后一个结点的父结点如图(a),我们找到的结点是16,然后找出该结点的最大子节点与自己比较,若该子节点比自身大,则将两个结点交换.
图(a)中,16是最大的结点,不需要交换.  
2.我们移动到第下一个父结点3,如图(b)所示.同理做第一步的操作,交换了3和14,结果如图(c)所示.  
3.移动结点到下一个父结点13,如图(d)所示,发现不需要做任何操作,  
4.移动到下个父结点1,如图(e)所示,然后交换1和16,如图(f)所示,此时我们发现交换后,1的子节点并不是最大的,我们接着在交换(如图g)所示  
5.移动到父结点到5,一次重复上述步骤,交换5和16,在交换14和5,在交换5和6  
所有节点交换完毕,最大堆构建完成
![两数之和](https://github.com/pqLee/leetcode/blob/master/images/heap.png)
## 应用
C++中priority_queue是堆模板，priority_queue底层就是堆实现
## 代码实现(C++)
```
//// 由数组建堆
void initHeap(std::vector<int>& arr, int size)
{
    // 寻找最后一个节点的父节点
    for (int pIndex = size/2; pIndex > 0; pIndex--)
    {
        int tmp = pIndex - 1;
        while((tmp*2) <= size - 1)   // 表示该节点有孩子节点——>如果该节点为叶子节点，循环结束
        {
            // 寻找这个节点的最大子节点
            int maxChildIndex = 0; 
            if ((tmp*2) + 1 > size - 1) // 该节点没有右孩子，则左孩子是最大节点
            {
                maxChildIndex = tmp*2;
            }
            else
            {
                maxChildIndex = arr[tmp*2]>arr[tmp*2+1] ? tmp*2 : tmp*2+1; 
            }

            // 比较最大子节点和当前父节点，如果父节点的值小于最大子节点，交换两个节点
            if (arr[tmp] < arr[maxChildIndex])
            {
                int a = arr[tmp];
                arr[tmp] = arr[maxChildIndex];
                arr[maxChildIndex] = a;
                tmp = maxChildIndex;
            }
            else
            {
                // 当该节点不再需要交换时，结束向下查找(退出while循环)
                break;
            } // 故结束这个while循环有两个方式：到达子节点和该节点不需要交换

        }
    }
}

/* 堆排序（Heapsort）是指利用堆这种数据结构（所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：  
        大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；  
        小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；  
        堆排序的平均时间复杂度为 Ο(nlogn)
   算法步骤：  
        创建一个堆 H[0……n-1]；
        把堆首（最大值）和堆尾互换；
        把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；
        重复步骤 2，直到堆的尺寸为 1
*/
```



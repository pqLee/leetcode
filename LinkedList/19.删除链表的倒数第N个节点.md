## 题目地址
https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/

## 题目描述
```
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：
给定一个链表: 1->2->3->4->5, 和 n = 2.
当删除了倒数第二个节点后，链表变为 1->2->3->5.

说明：
给定的 n 保证是有效的。

进阶：
你能尝试使用一趟扫描实现吗？
```
## 思路
本题有两种解法  
一、两次遍历  
二、一次遍历，使用双指针，两个指针之间相隔n，如下图：

## 代码
* 语言支持：C++，python3
> C++代码
```c++
class Solution()
{
	ListNode* res = new ListNode(0);;
	ListNode* head_res = res;
	int carry = 0;
	while (l1 != NULL || l2 != NULL)
	{
	    int x = (l1 != NULL) ? l1->val : 0;
	    int y = (l2 != NULL) ? l2->val : 0;
	    int sum = x + y + carry;
	    carry = sum / 10;
	    head_res->next = new ListNode(sum % 10);
	    head_res = head_res->next;
	    if (l1 != NULL)
		l1 = l1->next;
	    if (l2 != NULL)
		l2 = l2->next;
	}
	if (carry > 0)
	    head_res->next = new ListNode(carry);
	res = res->next;
	return res;
};
```
> python代码
```
class Solution:
    def addTwoNumbers(self, l1, l2):
        res = ListNode(0)
        head = res
        carry = 0
        p = l1
        q = l2
        while (p != None or q != None):
            x = p.val if (p != None) else 0 
            y = q.val if (q != None) else 0            
            sum = x + y + carry
            carry = sum // 10
            # print("p val : ", p.val, "q val : ", q.val)
            # print("carry : ", carry)
            # print("sum : ", sum)
            head.next = ListNode(sum % 10)
            if p != None:
                p = p.next
            if q != None:
                q = q.next
            # print("head val : ", head.val)
            head = head.next
        if carry > 0:
            head.next = ListNode(carry)
        res = res.next
        return res
```
